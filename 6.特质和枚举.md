# 特质和枚举

## 6.1 特质用作接口

### 问题

你习惯于在其他语言（如Java）中创建纯粹的接口 —— 声明方法签名而没有实现，并希望在Scala中使用类似的东西，然后用具体的类来实现这些接口。

### 解决方法

在最基本的层面上，Scala 特质可以像Java 8之前的接口那样使用，在那里你可以定义方法签名，但不为它们提供实现。

例如，想象一下，你想写一些代码来模拟任何有尾巴的动物，如狗或猫。你可能首先想到的是尾巴可以摇摆，所以你定义了一个这样的特质，它里面有两个方法签名，但没有方法体：
```
    trait HasTail:
        def startTail(): Unit
        def stopTail(): Unit
```

这两个方法不接受任何参数。如果你想定义的方法需要带参数，像往常一样声明它们即可：
```
    trait HasLegs:
        def startRunning(speed: Double): Unit
        def runForNSeconds(speed: Double, numSeconds: Int): Unit
```

#### 继承特质

在这个过程的另一面，当你想创建一个继承特质的类时，使用 **extends** 关键字：
```
    class Dog extends HasTail
```

当一个类扩展了多个特质时，对第一个特质使用 **extends**，并以逗号分隔后续的特质：
```
    class Dog extends HasTail, HasLegs, HasRubberyNose
```

如果一个类扩展了一个特质，但没有实现其它的抽象方法，那么这个类必须被声明为抽象类：
```
    // Dog类没有实现HasTail和HasLegs的抽象方法，所以必须定义为abstract
    abstract class Dog extends HasTail, HasLegs:
```

但是如果这个类为它继承的特质的所有抽象方法都提供了实现，那么这个类就可以被声明为一个普通的类：
```
    class Dog extends HasTail, HasLegs:
        def startTail(): Unit = println("Tail is wagging")
        def stopTail(): Unit = println("Tail is stopped")
        def startRunning(speed: Double): Unit =
            println(s"Running at $speed miles/hour")
        def runForNSeconds(speed: Double, numSeconds: Int): Unit =
            println(s"Running at $speed miles/hour for $numSeconds seconds")
```

### 讨论

如这些例子所示，在其最基本的层面上，特质可以作为简单的接口使用。类使用 **extends** 关键字来继承特质，遵从以下这些规则：

- 如果一个类继承一个特质，使用 **extends** 关键字。
- 如果一个类继承多个特质，第一个特质使用 **extends** ，其余的用逗号分开。
- 如果一个类继承一个类（或抽象类）和一个特质，总是先列出类的名称 —— 在类的名称前使用 **extends** ，然后在额外的特质名称前使用逗号。

正如你将在下面的一些示例中看到的那样，特质也可以继承其他特质：
```
    trait SentientBeing:
        def imAlive_!(): Unit = println("I’m alive!")
    trait Furry
    trait Dog extends SentientBeing, Furry
```

### 另见

对象也可以继承特质来创建模块，在6.11小节的示例中展示了这种技术。

## 6.2 在特质中定义抽象字段

### 问题

你想声明一个特质并拥有一个字段，但你不想给这个字段赋初始值，也就是说，你希望它是抽象的。

### 解决方法

随着时间的推移，Scala开发者已经认识到，在特质中定义抽象字段的最简单和最灵活的方法是使用 **def**：
```
    trait PizzaTrait:
        def maxNumToppings: Int
```

这让你可以在继承你的特质的类（和特质）中以各种方式重写该字段，包括作为一个 **val**：
```
    class SmallPizza extends PizzaTrait:
        val maxNumToppings = 4
```

作为一个 **lazy val**：
```
    class SmallPizza extends PizzaTrait:
        lazy val maxNumToppings = 4
        // some long-running operation
        Thread.sleep(1_000)
```

作为一个 **var**：
```
    class MediumPizza extends PizzaTrait:
        var maxNumToppings = 6
```

或者作为一个 **def**：
```
    class LargePizza extends PizzaTrait:
        def maxNumToppings: Int = 42
        // some algorithm here
```

### 讨论

特质中的字段可以是具体的或抽象的。 
- 如果你给它赋了一个值，它就是具体的。
- 如果你不给它赋值，它就是抽象的。

从实现的角度看，这就很简单了：
```
    trait Foo:
        def bar: Int // 抽象方法
        val a = 1 // 具体 val 值
        var b = 2 // 具体 var 值
```

虽然有这些选择，但随着时间的推移，Scala开发者了解到，在特质中定义字段最灵活、最抽象的方法是将它们声明为 **def**。如解决方法所示，这为你在继承特质的类中实现该字段提供了多种方式。换句话说，如果你把一个抽象字段定义为 **var** 或 **val**，就会大大限制你在继承类中的选择。

#### 特质中的具体字段

如果你确实想在特质中定义一个具体的 **val** 或 **var** 字段，像IntelliJ IDEA或VS Code这样的IDE可以帮助你确定在继承特质的类中可以做什么和不可以做什么。例如，如果你在特质中指定了一个具体的 **var** 字段，你会发现你在继承这个特质的类中可以重写这个值：
```
    trait SentientBeing:
        var uuid = 0 // 具体字段
    class Person extends SentientBeing:
        uuid = 1
```

同样地，如果你将一个特质字段定义为一个具体的值，你需要使用 **override** 修饰符来改变继承类中的值：
```
    trait Cat:
        val numLives = 9 // 具体的
    class BetterCat extends Cat:
        override val numLives = 10
```

在这两种情况下，你都 *不能* 在你的类中把这些字段实现为 **def** 或 **lazy val** 值。

### 另见

Scala开发者在一段时间内了解了 **def** 方式的原理。使用这种方式的部分原因与JVM的工作方式有关，因此也与Scala如何编译特质以适应JVM有关。这是一个很漫长的讨论，如果你对细节感兴趣，我在我的博文“Scala Traits中的def、val和var字段在编译后是什么样子（包括继承它们的类）”中详细描述了这一点。（ *https://oreil.ly/ID6C3* ）

## 6.3 像抽象类一样使用特质

你想把特质作为类似于Java中的抽象类的东西来使用，同时定义抽象和具体的方法。

### 问题

根据需要在你的特质中定义具体和抽象方法。在继承特质的类中，你可以重写这两种类型的方法，或者，对于具体方法，你可以继承特质中定义的默认行为。

在下面的例子中，特质 **Pet** 中的 **speak** 方法有一个默认的、具体的实现，所以实现类不需要重写它。类 **Dog** 选择不重写它，而类 **Cat** 则选择重写。两个类都必须实现 **comeToMaster** 方法，因为它在特质 **Pet** 中没有默认的实现：
```
    trait Pet:
        def speak() = println("Yo") // 具体实现
        def comeToMaster(): Unit // 抽象方法
    class Dog extends Pet:
        // 可以不用重写 `speak`
        def comeToMaster() = println("I'm coming!")
    class Cat extends Pet:
        override def speak() = println("meow")
        def comeToMaster() = println("That’s not gonna happen.")
```

如果一个类继承了一个特质而没有实现其抽象方法，它必须被声明为抽象的。因为 **FlyingPet** 并没有实现 **comeToMaster**，所以它必须被声明为抽象的：
```
    abstract class FlyingPet extends Pet:
        def fly() = println("Woo-hoo, I’m flying!")
```

### 讨论

虽然Scala有抽象类，但使用特质比抽象类实现基础行为要 *普遍* 得多。一个类只能继承一个抽象类，但它可以实现（继承）多个特质，所以使用特质更加灵活。因为Scala 3还允许特质拥有构造器参数，这使得它将能被用于更多的场合。

### 另见

- 关于在Scala 3中使用特质参数的细节，请参见6.9小节。
- 关于何时使用抽象类而不是特质的信息，请参见5.1小节中的“还有一件事：何时使用抽象类”。

## 6.4 特质用作混入

## 6.5 解决方法名称冲突和理解super

## 6.6 限定特质只可用于指定类型的子类

## 6.7 保证特质只能被添加到具有特定方法的类型中

## 6.8 通过继承来限定特质的使用范围

## 6.9 使用参数化特质

## 6.10 使用特质参数

## 6.11 使用特质创建模块

## 6.12 如何使用枚举创建命名值集

## 6.13 用枚举为代数数据类型建模