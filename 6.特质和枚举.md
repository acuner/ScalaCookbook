# 特质和枚举

## 6.1 特质用作接口

### 问题

你习惯于在其他语言（如Java）中创建纯粹的接口 —— 声明方法签名而没有实现，并希望在Scala中使用类似的东西，然后用具体的类来实现这些接口。

### 解决方法

在最基本的层面上，Scala 特质可以像Java 8之前的接口那样使用，在那里你可以定义方法签名，但不为它们提供实现。

例如，想象一下，你想写一些代码来模拟任何有尾巴的动物，如狗或猫。你可能首先想到的是尾巴可以摇摆，所以你定义了一个这样的特质，它里面有两个方法签名，但没有方法体：
```
    trait HasTail:
        def startTail(): Unit
        def stopTail(): Unit
```

这两个方法不接受任何参数。如果你想定义的方法需要带参数，像往常一样声明它们即可：
```
    trait HasLegs:
        def startRunning(speed: Double): Unit
        def runForNSeconds(speed: Double, numSeconds: Int): Unit
```

#### 继承特质

在这个过程的另一面，当你想创建一个继承特质的类时，使用 **extends** 关键字：
```
    class Dog extends HasTail
```

当一个类扩展了多个特质时，对第一个特质使用 **extends**，并以逗号分隔后续的特质：
```
    class Dog extends HasTail, HasLegs, HasRubberyNose
```

如果一个类扩展了一个特质，但没有实现其它的抽象方法，那么这个类必须被声明为抽象类：
```
    // Dog类没有实现HasTail和HasLegs的抽象方法，所以必须定义为abstract
    abstract class Dog extends HasTail, HasLegs:
```

但是如果这个类为它继承的特质的所有抽象方法都提供了实现，那么这个类就可以被声明为一个普通的类：
```
    class Dog extends HasTail, HasLegs:
        def startTail(): Unit = println("Tail is wagging")
        def stopTail(): Unit = println("Tail is stopped")
        def startRunning(speed: Double): Unit =
            println(s"Running at $speed miles/hour")
        def runForNSeconds(speed: Double, numSeconds: Int): Unit =
            println(s"Running at $speed miles/hour for $numSeconds seconds")
```

### 讨论

如这些例子所示，在其最基本的层面上，特质可以作为简单的接口使用。类使用 **extends** 关键字来继承特质，遵从以下这些规则：

- 如果一个类继承一个特质，使用 **extends** 关键字。
- 如果一个类继承多个特质，第一个特质使用 **extends** ，其余的用逗号分开。
- 如果一个类继承一个类（或抽象类）和一个特质，总是先列出类的名称 —— 在类的名称前使用 **extends** ，然后在额外的特质名称前使用逗号。

正如你将在下面的一些示例中看到的那样，特质也可以继承其他特质：
```
    trait SentientBeing:
        def imAlive_!(): Unit = println("I’m alive!")
    trait Furry
    trait Dog extends SentientBeing, Furry
```

### 另见

对象也可以继承特质来创建模块，在6.11小节的示例中展示了这种技术。

## 6.2 在特质中定义抽象字段

### 问题

你想声明一个特质并拥有一个字段，但你不想给这个字段赋初始值，也就是说，你希望它是抽象的。

### 解决方法

随着时间的推移，Scala开发者已经认识到，在特质中定义抽象字段的最简单和最灵活的方法是使用 **def**：
```
    trait PizzaTrait:
        def maxNumToppings: Int
```

这让你可以在继承你的特质的类（和特质）中以各种方式重写该字段，包括作为一个 **val**：
```
    class SmallPizza extends PizzaTrait:
        val maxNumToppings = 4
```

作为一个 **lazy val**：
```
    class SmallPizza extends PizzaTrait:
        lazy val maxNumToppings = 4
        // some long-running operation
        Thread.sleep(1_000)
```

作为一个 **var**：
```
    class MediumPizza extends PizzaTrait:
        var maxNumToppings = 6
```

或者作为一个 **def**：
```
    class LargePizza extends PizzaTrait:
        def maxNumToppings: Int = 42
        // some algorithm here
```

### 讨论

特质中的字段可以是具体的或抽象的。 
- 如果你给它赋了一个值，它就是具体的。
- 如果你不给它赋值，它就是抽象的。

从实现的角度看，这就很简单了：
```
    trait Foo:
        def bar: Int // 抽象方法
        val a = 1 // 具体 val 值
        var b = 2 // 具体 var 值
```

虽然有这些选择，但随着时间的推移，Scala开发者了解到，在特质中定义字段最灵活、最抽象的方法是将它们声明为 **def**。如解决方法所示，这为你在继承特质的类中实现该字段提供了多种方式。换句话说，如果你把一个抽象字段定义为 **var** 或 **val**，就会大大限制你在继承类中的选择。

#### 特质中的具体字段

如果你确实想在特质中定义一个具体的 **val** 或 **var** 字段，像IntelliJ IDEA或VS Code这样的IDE可以帮助你确定在继承特质的类中可以做什么和不可以做什么。例如，如果你在特质中指定了一个具体的 **var** 字段，你会发现你在继承这个特质的类中可以重写这个值：
```
    trait SentientBeing:
        var uuid = 0 // 具体字段
    class Person extends SentientBeing:
        uuid = 1
```

同样地，如果你将一个特质字段定义为一个具体的值，你需要使用 **override** 修饰符来改变继承类中的值：
```
    trait Cat:
        val numLives = 9 // 具体的
    class BetterCat extends Cat:
        override val numLives = 10
```

在这两种情况下，你都 *不能* 在你的类中把这些字段实现为 **def** 或 **lazy val** 值。

### 另见

Scala开发者在一段时间内了解了 **def** 方式的原理。使用这种方式的部分原因与JVM的工作方式有关，因此也与Scala如何编译特质以适应JVM有关。这是一个很漫长的讨论，如果你对细节感兴趣，我在我的博文“Scala Traits中的def、val和var字段在编译后是什么样子（包括继承它们的类）”中详细描述了这一点。（ *https://oreil.ly/ID6C3* ）

## 6.3 像抽象类一样使用特质

你想把特质作为类似于Java中的抽象类的东西来使用，同时定义抽象和具体的方法。

### 问题

根据需要在你的特质中定义具体和抽象方法。在继承特质的类中，你可以重写这两种类型的方法，或者，对于具体方法，你可以继承特质中定义的默认行为。

在下面的例子中，特质 **Pet** 中的 **speak** 方法有一个默认的、具体的实现，所以实现类不需要重写它。类 **Dog** 选择不重写它，而类 **Cat** 则选择重写。两个类都必须实现 **comeToMaster** 方法，因为它在特质 **Pet** 中没有默认的实现：
```
    trait Pet:
        def speak() = println("Yo") // 具体实现
        def comeToMaster(): Unit // 抽象方法
    class Dog extends Pet:
        // 可以不用重写 `speak`
        def comeToMaster() = println("I'm coming!")
    class Cat extends Pet:
        override def speak() = println("meow")
        def comeToMaster() = println("That’s not gonna happen.")
```

如果一个类继承了一个特质而没有实现其抽象方法，它必须被声明为抽象的。因为 **FlyingPet** 并没有实现 **comeToMaster**，所以它必须被声明为抽象的：
```
    abstract class FlyingPet extends Pet:
        def fly() = println("Woo-hoo, I’m flying!")
```

### 讨论

虽然Scala有抽象类，但使用特质比抽象类实现基础行为要 *普遍* 得多。一个类只能继承一个抽象类，但它可以实现（继承）多个特质，所以使用特质更加灵活。因为Scala 3还允许特质拥有构造器参数，这使得它将能被用于更多的场合。

### 另见

- 关于在Scala 3中使用特质参数的细节，请参见6.9小节。
- 关于何时使用抽象类而不是特质的信息，请参见5.1小节中的“还有一件事：何时使用抽象类”。

## 6.4 特质用作混入

### 问题

你想设计一个具备鲁棒性的解决方法，其中一个或多个特质可以被混入（mixin）到一个类中。

### 解决方法

要使用特质作为混入，只需要像往常一样，将特质中的方法定义为抽象或具体的方法，然后使用 **extends** 将特质混入你的类。这至少可以通过两种不同的方式实现：
- 用特质构建一个类
- 在构建变量时混入特质

#### 用特质构建一个类

第一种方法是创建一个类，同时扩展一个或多个特质。例如，设想你有这两个特质：
```
    trait HasTail:
        def wagTail() = println("Tail is wagging")
        def stopTail() = println("Tail is stopped")
    trait Pet:
        def speak() = println("Yo")
        def comeToMaster(): Unit // 抽象的
```

**HasTail** 中的方法都是具体的，而 **Pet** 中的 **comeToMaster** 方法是抽象的，因为该方法没有方法体。现在你可以通过混入这些特质并实现 **comeToMaster** 来创建一个具体的 **Dog** 类：
```
    class Dog(val name: String) extends Pet, HasTail:
        def comeToMaster() = println("Woo-hoo, I'm coming!")
    
    val d = Dog("Zeus")
```

使用同样的方法，你可以创建一个 **Cat** 类，以不同的方式实现 **comeToMaster** ，同时也重写 **speak** 方法：
```
    class Cat(val name: String) extends Pet, HasTail:
        def comeToMaster() = println("That’s not gonna happen.")
        override def speak() = println("meow")
    
    val c = Cat("Morris")
```

#### 在构建变量时混入特质

另一种混入方法是在创建一个变量的同时，将特质添加到一个类中。想象一下，你现在有这三个特质（它们没有方法）和一个 **Pet** 类：
```
    trait HasLegs
    trait HasTail
    trait MansBestFriend
    class Pet(val name: String)
```

现在你可以创建一个新的 **Pet** 实例，同时也可以为这个特定的变量混入你想要的特特质：
```
    val zeus = new Pet("Zeus") with MansBestFriend with HasTail with HasLegs
```

然后你可以通过混入有意义的特质来创建其他变量：
```
    val cat = new Pet("Morris") with HasTail with HasLegs
```

### 讨论

我展示了两种方法，因为不同的人对 **mixin** 的含义有不同定义。当我第一次了解到混入时，主要的用例是第二个例子，它展示如何在创建变量时混入一个特质。

但是现在，当多个特质被用来组成一个类时，都可以使用 **mixin** 这个术语。这是因为这些特质并不是类的唯一父类，而是它们被混入到类中。例如，维基百科上的mixin页面（ **https://oreil.ly/YpON2** ）提供了一个很好的方法来思考这个问题，它指出混入是“被描述为‘包含’而不是‘继承’”。

这是特质的一个关键好处：它们让你通过将大问题分解成小问题来构建模块化的行为单元。 例如，与其试图设计一个大型的 **Dog** 类，理解构成狗的较小 *组件* 更加容易 ，并将问题分解为与拥有尾巴、腿、毛发、耳朵等有关的特质，然后将这些特质混入到一起，创建一只狗。通过这样做，你创建了小的、细化的模块，这使得设计更容易理解和测试，而且这些模块也可以用来创建其他东西，如猫、马等。

将特质作为混入元素使用的几个关键是：
- 创建范围和功能集中的小单元。
- 实现你能实现的方法，并将其他方法声明为抽象方法。
- 因为特质有一个集中的责任区域，它们通常会实施不相关的行为（也称为正交行为）。


#### 可叠加特质模式 -- TODO 耗子栏

要想看到混入的强大力量的一个很好的实例，请阅读Bill Venners关于可堆叠特质模式的Artima短文（ *https://oreil.ly/U8WF1* ）。通过将特质和类定义为 *基础* 、*核心* 和 *可堆叠* 的，该文章演示了如何通过堆叠从三个特质中派生出16个不同的类。

关于混入的最后一点说明，Cay S. Horstmann的 *Scala for the Impatient*（Addison-Wesley Professional）一书中提出了一个观点：从哲学上讲，这段代码：
```
    class Pet(val name: String) extends HasLegs, HasTail, MansBestFriend
```

不是读作“class Pet extends HasLegs ‘with HasTail and MansBestFriend’”，而是读作“class Pet extends ‘HasLegs, HasTail, and MansBestFriend.’”，这是一个微妙的观点，说明一个类平等地混入了所有这些特质，而不是以任何特殊的方式偏爱第一个特质。

### 另见 

当你开发特质时，你可能想限制它们可以混入的类。这可以通过以下技术来实现：
- 本书6.6小节展示了如何标记特质，以便它们只能被某一类型的子类使用。
- 本书6.7小节展示了用来确保一个特质只能被混入有特定方法的类中。
- 本书6.8小节展示了如何通过声明来限制哪些类可以使用特质的继承性。
- 本书7.7小节，“将特质重塑为对象”，展示了如何创建一个混合了多个特质的 **object**。
- Bill Venners的Artima短文“可堆叠的特质模式”（ *https://oreil.ly/U8WF1* ）展示了如何通过将特质堆叠在一起而衍生出许多不同的类。

## 6.5 解决方法名称冲突和理解super

### 问题

你试图创建一个混入了多个特质的类，但这些特质有相同的方法名称和参数列表，导致编译器错误。

### 解决方法

当混入的两个或更多的特质共享相同的方法名时，解决方法是，手动解决这个冲突。这可能需要理解在提到混入在一起的特质时 **super** 的含义。

作为一个例子，设想你有两个特质都有一个 **greet** 方法：
```
    trait Hello:
        def greet = "hello"
    trait Hi:
        def greet = "hi"
```

现在，如果你试图创建一个混入了这两种特质的 **Greeter** 类：
```
    class Greeter extends Hello, Hi
```

你会看到类似这样的错误：
```
    class Greeter extends Hello, Hi
          ^
class Greeter inherits conflicting members:
       |method greet in trait Hello of type |=> String and
       |method greet in trait Hi of type |=> String
(Note: this can be resolved by declaring an override in class Greeter.)
```

错误信息告诉你解决方法 —— 你可以重写 **Greeter** 类中的 **greet** 方法。但它并没有给出如何做的细节。

有三个主要的解决方法，所有这些都需要你在以下内容中覆写 **Greeter** 类中的 **greet** 方法：
- 用自定义行为重写 **greet** 。
- 告诉 **Greeter** 中的 **greet** 要从 **super** 中调用 **greet** 方法，这就提出了一个问题：“当你混入多个特征时，**super** 指的是什么？”
- 告诉 **Greeter** 中的 **greet** 使用混入其中的指定特质的 **greet**方法。

下面几节将详细介绍每种解决方法。

#### 用自定义行为重写greet

第一个解决方法是忽略特质中定义的方法，通过重写方法实现一些自定义行为：
```
    // 通过在类上重写greet方法来解决冲突
    class Greeter extends Hello, Hi:
        override def greet = "I greet thee!"
    // greet方法按预期工作
    val g = Greeter()
    g.greet == "I greet thee!" // true
```

这是一个简单明了的解决方法，适用于你不关心特质如何实现这种方法的情况。

#### 用super调用greet

第二个解决方法是按照你的直属父级，即 **super** 实例中的定义来调用该方法。在这段代码中，**Speaker** 类中的 **speak** 方法调用了 **super.speak**：
```
    trait Parent:
        def speak = "make your bed"
    trait Granddad:
        def speak = "get off my lawn"
        // 通过调用super.speak解决冲突
    class Speaker extends Parent, Granddad:
        override def speak = super.speak
    @main def callSuperSpeak =
        println(Speaker().speak)
```

问题是，**super.speak** 打印的是什么？

答案是 **super.speak** 会打印出“get off my lawn”。在这样一个例子中，一个类混入了多个特质 —— 而且这些特质之间没有混入或继承关系 —— **super** 将总是指 *最后一个混入的特质* 。这被称为 *从后向前的线性化* 顺序。

#### 控制你所调用的super

在第三种解决方法中，你要指定你想调用的混入特质的方法，并使用 **super[classname].methodName** 语法来指定你要调用哪个被混入的特质的方法。例如，给定这三个特质：
```
    trait Hello:
        def greet = "hello"
    trait Hi:
        def greet = "hi"
    trait Yo:
        def greet = "yo"
```

你可以创建一个 **Greeter** 类，它混入了这些特质，然后定义了一系列的 **greet** 方法，调用这些特质的 **greet** 方法：
```
    class Greeter extends Hello, Hi, Yo:
        override def greet = super.greet
        def greetHello = super[Hello].greet
        def greetHi = super[Hi].greet
        def greetYo = super[Yo].greet
    end Greeter
```

你可以在REPL中用这段代码测试该配置：
```
    val g = Greeter()
    g.greet // yo
    g.greetHello // hello
    g.greetHi // hi
    g.greetYo // yo
```

这个解决方法的关键是 **super[Hello].greet** 语法给了你一种方法来引用 **Hello** 特质的 **hello** 方法，以此类推，**Hi** 和 **Yo** 特质也是如此。注意在 **g.greet** 的例子中，**super** 再次引用了混入的最后一个特质。

### 讨论

### 另见

## 6.6 限定特质只可用于指定类型的子类

## 6.7 保证特质只能被添加到具有特定方法的类型中

## 6.8 通过继承来限定特质的使用范围

## 6.9 使用参数化特质

## 6.10 使用特质参数

## 6.11 使用特质创建模块

## 6.12 如何使用枚举创建命名值集

## 6.13 用枚举为代数数据类型建模


- 译者注1 线性化
- 译者注2 super